import java.net.*;

/**
 * Client class that creates a "client" that sends packages to the intermediate host.
 *
 * Client can send either read (0 1) or write (0 2) requests as a preamble, name od the file with extension and
 * type of request (eg. netascii or octet).
 *
 * Support usage of the PacketSocketHelper class.
 *
 * @author  Dmytro Sytnik (VanArman)
 * @version 11 January 2019
 * @see PacketSocketHelper
 */
public class Client {

    private DatagramSocket sendReceiveSocket;
    private DatagramPacket sendPacket, receivePacket;
    private final PacketSocketHelper psh;

    /**
     * Default constructor that creates a send-receive DatagramSocket.
     * Creates an object of PacketSocketHelper class in order to send, receive and print data.
     *
     * @see PacketSocketHelper
     */
    public Client() {
        try {
            sendReceiveSocket = new DatagramSocket();
        } catch(SocketException se) {
            se.getMessage();
            System.exit(1);
        }

        psh = new PacketSocketHelper();
    }

    /**
     * Sends data to the intermediate host using specified port. (default port can be found in Host class)
     *
     * @param message String message that has to be sent (eq. text.txt)
     * @param port int port of the intermediate host (default 23)
     * @param requestType int request type 1 for read, 2 - write
     */
    private void sendData(String message, int port, int requestType) {
        byte[] msg = sendingMsgFormation(message, requestType, "ocTEt");
        sendPacket = psh.sendPacket(sendReceiveSocket, msg, port);
        psh.print(sendPacket, "Client", "sent to Host");
    }

    /**
     * Receiving response from the host that was generated by the server after validation of the sent packet.
     */
    private void receiveMessage() {
        receivePacket = psh.receivePacket(sendReceiveSocket);
        psh.print(receivePacket, "Client", "received bonce message");
    }

    /**
     * Forms message that would be send to the server through intermediate host
     *
     * @param s String message to send (eg. text.txt)
     * @param requestType int request type 1 for read, 2 - write
     * @param mode String type of request (eg. netascii or octet).
     * @return byte[] array of bytes that follows next pattern "0 [1|2] 0 message.byte 0 mode.byte 0";
     */
    private byte[] sendingMsgFormation(String s, int requestType, String mode) {
        // calculate total length of the message
        int totalSize = 2 + s.getBytes().length + mode.getBytes().length + 2;

        // initial size after adding preamble
        int size = 2;

        // create byte array that would be sent
        byte[] sendData = new byte[totalSize];

        // assign byte[0] as "0"
        sendData[0] = (byte) 0;

        // assign byte[1] based on the request type: 1 for read, 2 - write, otherwise will set 0
        switch (requestType) {
            case 1:
                sendData[1] = (byte) 1;
                break;
            case 2:
                sendData[1] = (byte) 2;
                break;
            default:
                sendData[1] = (byte) 0;
                break;
        }

        // message converted to the byte array coping to the byte array that would be sent
        System.arraycopy(s.getBytes(), 0, sendData, size, s.getBytes().length);

        // increment the size (index) after adding message
        size += s.getBytes().length;

        // set following "0" after message and increment size
        sendData[size++] = 0;

        // mode converted to the byte array copied to the byte array to sent
        System.arraycopy(mode.getBytes(), 0, sendData, size, mode.getBytes().length);

        // increment the size (index) after adding mode to the byte array
        size += mode.getBytes().length;

        // add following "0" after mode
        sendData[size] = 0;

        // return prepared byte array
        return sendData;
    }

    /**
     * Run all function in the defined sequence:
     * - send data to host
     * - receive response from the server
     *
     * @param requestType int request type 1 for read, 2 - write
     */
    public void run(int requestType, String message) {
        this.sendData(message, Host.HOST_PORT, requestType);
        this.receiveMessage();
    }

    /**
     * Entering point
     *
     * Create client object and perform finite loop were generates different request type (read, write and illegal).
     *
     * @param args String[] not used in current context
     */
    public static void main(String[] args) {
        Client c = new Client();

        int max = 3; // number of package will send
        String message = "test.txt"; // message to send

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e ) {
            e.printStackTrace();
            System.exit(1);
        }

        for(int i = 0; i < max; i++) {
            if(i == max-1) {
                c.run(0, message);
            } else {
                c.run((i % 2) + 1, message);
            }
        }
    }
}
